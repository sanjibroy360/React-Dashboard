{"ast":null,"code":"/*\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\nhttps://www.infragistics.com/legal/license/igultimate-la\nhttps://www.infragistics.com/legal/license/igultimate-eula\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\n*/\nimport * as tslib_1 from \"tslib\";\nimport { Base, fromEnum, toEnum, markType, getEnumerator } from \"./type\";\nimport { isNaN_ } from \"./number\";\n/**\n * @hidden\n */\n\nvar TrendCalculators =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(TrendCalculators, _super);\n\n  function TrendCalculators() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TrendCalculators._g = function (a, b) {\n    var c, d, e, f, g, h, _h, _j, i, j, e_1_1;\n\n    var e_1, _k;\n\n    return tslib_1.__generator(this, function (_l) {\n      switch (_l.label) {\n        case 0:\n          c = new Array(b);\n          d = 0;\n\n          for (d = 0; d < b; d++) {\n            c[d] = 0;\n          }\n\n          e = NaN;\n          f = NaN;\n          g = NaN;\n          h = NaN;\n          d = 0;\n          _l.label = 1;\n\n        case 1:\n          _l.trys.push([1, 6, 7, 8]);\n\n          _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n          _l.label = 2;\n\n        case 2:\n          if (!!_j.done) return [3\n          /*break*/\n          , 5];\n          i = _j.value;\n\n          if (!isNaN_(i)) {\n            j = d % b;\n\n            if (d == 0) {\n              g = 1;\n              h = i;\n              f = i;\n              e = i;\n            } else if (d < b) {\n              g += d + 1;\n              e += i;\n              f += (d + 1) * i;\n              h = f / g;\n            } else {\n              f = f + b * i - e;\n              h = f / g;\n              e = e + i - c[j];\n            }\n\n            c[j] = i;\n            ++d;\n          }\n\n          return [4\n          /*yield*/\n          , h];\n\n        case 3:\n          _l.sent();\n\n          _l.label = 4;\n\n        case 4:\n          _j = _h.next();\n          return [3\n          /*break*/\n          , 2];\n\n        case 5:\n          return [3\n          /*break*/\n          , 8];\n\n        case 6:\n          e_1_1 = _l.sent();\n          e_1 = {\n            error: e_1_1\n          };\n          return [3\n          /*break*/\n          , 8];\n\n        case 7:\n          try {\n            if (_j && !_j.done && (_k = _h.return)) _k.call(_h);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n\n          return [7\n          /*endfinally*/\n          ];\n\n        case 8:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  TrendCalculators.g = function (a, b) {\n    return toEnum(function () {\n      return TrendCalculators._g(a, b);\n    });\n  };\n\n  TrendCalculators._b = function (a, b) {\n    var c, d, e, _h, _j, f, e_2_1;\n\n    var e_2, _k;\n\n    return tslib_1.__generator(this, function (_l) {\n      switch (_l.label) {\n        case 0:\n          c = 0;\n          d = NaN;\n          e = 2 / (1 + b);\n          _l.label = 1;\n\n        case 1:\n          _l.trys.push([1, 6, 7, 8]);\n\n          _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n          _l.label = 2;\n\n        case 2:\n          if (!!_j.done) return [3\n          /*break*/\n          , 5];\n          f = _j.value;\n\n          if (!isNaN_(f)) {\n            if (c < b) {\n              d = isNaN_(d) ? f : (d * c + f) / (c + 1);\n            } else {\n              d = (f - d) * e + d;\n            }\n\n            ++c;\n          }\n\n          return [4\n          /*yield*/\n          , d];\n\n        case 3:\n          _l.sent();\n\n          _l.label = 4;\n\n        case 4:\n          _j = _h.next();\n          return [3\n          /*break*/\n          , 2];\n\n        case 5:\n          return [3\n          /*break*/\n          , 8];\n\n        case 6:\n          e_2_1 = _l.sent();\n          e_2 = {\n            error: e_2_1\n          };\n          return [3\n          /*break*/\n          , 8];\n\n        case 7:\n          try {\n            if (_j && !_j.done && (_k = _h.return)) _k.call(_h);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n\n          return [7\n          /*endfinally*/\n          ];\n\n        case 8:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  TrendCalculators.b = function (a, b) {\n    return toEnum(function () {\n      return TrendCalculators._b(a, b);\n    });\n  };\n\n  TrendCalculators._c = function (a, b) {\n    var c, d, e, _h, _j, f, e_3_1;\n\n    var e_3, _k;\n\n    return tslib_1.__generator(this, function (_l) {\n      switch (_l.label) {\n        case 0:\n          c = 0;\n          d = NaN;\n          e = 1 / b;\n          _l.label = 1;\n\n        case 1:\n          _l.trys.push([1, 6, 7, 8]);\n\n          _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n          _l.label = 2;\n\n        case 2:\n          if (!!_j.done) return [3\n          /*break*/\n          , 5];\n          f = _j.value;\n\n          if (!isNaN_(f)) {\n            if (c < b) {\n              d = isNaN_(d) ? f : (d * c + f) / (c + 1);\n            } else {\n              d = (f - d) * e + d;\n            }\n\n            ++c;\n          }\n\n          return [4\n          /*yield*/\n          , d];\n\n        case 3:\n          _l.sent();\n\n          _l.label = 4;\n\n        case 4:\n          _j = _h.next();\n          return [3\n          /*break*/\n          , 2];\n\n        case 5:\n          return [3\n          /*break*/\n          , 8];\n\n        case 6:\n          e_3_1 = _l.sent();\n          e_3 = {\n            error: e_3_1\n          };\n          return [3\n          /*break*/\n          , 8];\n\n        case 7:\n          try {\n            if (_j && !_j.done && (_k = _h.return)) _k.call(_h);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n\n          return [7\n          /*endfinally*/\n          ];\n\n        case 8:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  TrendCalculators.c = function (a, b) {\n    return toEnum(function () {\n      return TrendCalculators._c(a, b);\n    });\n  };\n\n  TrendCalculators._a = function (a) {\n    var b, c, _h, _j, d, e_4_1;\n\n    var e_4, _k;\n\n    return tslib_1.__generator(this, function (_l) {\n      switch (_l.label) {\n        case 0:\n          b = NaN;\n          c = 0;\n          _l.label = 1;\n\n        case 1:\n          _l.trys.push([1, 6, 7, 8]);\n\n          _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n          _l.label = 2;\n\n        case 2:\n          if (!!_j.done) return [3\n          /*break*/\n          , 5];\n          d = _j.value;\n\n          if (!isNaN_(d)) {\n            b = isNaN_(b) ? d : (b * c + d) / (c + 1);\n            ++c;\n          }\n\n          return [4\n          /*yield*/\n          , b];\n\n        case 3:\n          _l.sent();\n\n          _l.label = 4;\n\n        case 4:\n          _j = _h.next();\n          return [3\n          /*break*/\n          , 2];\n\n        case 5:\n          return [3\n          /*break*/\n          , 8];\n\n        case 6:\n          e_4_1 = _l.sent();\n          e_4 = {\n            error: e_4_1\n          };\n          return [3\n          /*break*/\n          , 8];\n\n        case 7:\n          try {\n            if (_j && !_j.done && (_k = _h.return)) _k.call(_h);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n\n          return [7\n          /*endfinally*/\n          ];\n\n        case 8:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  TrendCalculators.a = function (a) {\n    return toEnum(function () {\n      return TrendCalculators._a(a);\n    });\n  };\n\n  TrendCalculators._e = function (a, b) {\n    var c, d, e, _h, _j, f, g, h, e_5_1;\n\n    var e_5, _k;\n\n    return tslib_1.__generator(this, function (_l) {\n      switch (_l.label) {\n        case 0:\n          c = new Array(b);\n          d = 0;\n\n          for (d = 0; d < b; d++) {\n            c[d] = 0;\n          }\n\n          d = 0;\n          e = NaN;\n          _l.label = 1;\n\n        case 1:\n          _l.trys.push([1, 6, 7, 8]);\n\n          _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n          _l.label = 2;\n\n        case 2:\n          if (!!_j.done) return [3\n          /*break*/\n          , 5];\n          f = _j.value;\n\n          if (!isNaN_(f)) {\n            g = f / b;\n            h = d % b;\n\n            if (d < b) {\n              e = isNaN_(e) ? f : (e * d + f) / (d + 1);\n            } else {\n              e = e + g - c[h];\n            }\n\n            c[h] = g;\n            ++d;\n          }\n\n          return [4\n          /*yield*/\n          , e];\n\n        case 3:\n          _l.sent();\n\n          _l.label = 4;\n\n        case 4:\n          _j = _h.next();\n          return [3\n          /*break*/\n          , 2];\n\n        case 5:\n          return [3\n          /*break*/\n          , 8];\n\n        case 6:\n          e_5_1 = _l.sent();\n          e_5 = {\n            error: e_5_1\n          };\n          return [3\n          /*break*/\n          , 8];\n\n        case 7:\n          try {\n            if (_j && !_j.done && (_k = _h.return)) _k.call(_h);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n\n          return [7\n          /*endfinally*/\n          ];\n\n        case 8:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  TrendCalculators.e = function (a, b) {\n    return toEnum(function () {\n      return TrendCalculators._e(a, b);\n    });\n  };\n\n  TrendCalculators._d = function (a, b) {\n    var c, d, e, _h, _j, f, g, h, e_6_1;\n\n    var e_6, _k;\n\n    return tslib_1.__generator(this, function (_l) {\n      switch (_l.label) {\n        case 0:\n          c = new Array(b);\n          d = 0;\n\n          for (d = 0; d < b; d++) {\n            c[d] = 0;\n          }\n\n          d = 0;\n          e = NaN;\n          _l.label = 1;\n\n        case 1:\n          _l.trys.push([1, 6, 7, 8]);\n\n          _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n          _l.label = 2;\n\n        case 2:\n          if (!!_j.done) return [3\n          /*break*/\n          , 5];\n          f = _j.value;\n\n          if (!isNaN_(f)) {\n            g = f;\n            h = d % b;\n\n            if (d < b) {\n              e = isNaN_(e) ? g : e + g;\n            } else {\n              e = e + g - c[h];\n            }\n\n            c[h] = g;\n            ++d;\n          }\n\n          return [4\n          /*yield*/\n          , e];\n\n        case 3:\n          _l.sent();\n\n          _l.label = 4;\n\n        case 4:\n          _j = _h.next();\n          return [3\n          /*break*/\n          , 2];\n\n        case 5:\n          return [3\n          /*break*/\n          , 8];\n\n        case 6:\n          e_6_1 = _l.sent();\n          e_6 = {\n            error: e_6_1\n          };\n          return [3\n          /*break*/\n          , 8];\n\n        case 7:\n          try {\n            if (_j && !_j.done && (_k = _h.return)) _k.call(_h);\n          } finally {\n            if (e_6) throw e_6.error;\n          }\n\n          return [7\n          /*endfinally*/\n          ];\n\n        case 8:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  TrendCalculators.d = function (a, b) {\n    return toEnum(function () {\n      return TrendCalculators._d(a, b);\n    });\n  };\n\n  TrendCalculators._f = function (a, b) {\n    var c, d, e, f, g, h, i, j, k, l;\n    return tslib_1.__generator(this, function (_h) {\n      switch (_h.label) {\n        case 0:\n          c = getEnumerator(TrendCalculators.e(a, b));\n          d = getEnumerator(a);\n          e = new Array(b);\n          f = 0;\n\n          for (f = 0; f < b; f++) {\n            e[f] = 0;\n          }\n\n          f = 0;\n          _h.label = 1;\n\n        case 1:\n          if (!(d.moveNext() && c.moveNext())) return [3\n          /*break*/\n          , 6];\n          e[f++ % b] = d.current;\n          g = 0;\n          if (!(f < b)) return [3\n          /*break*/\n          , 3];\n          h = 0;\n\n          for (i = 0; i < f; i++) {\n            j = c.current - e[i];\n            g += j * j;\n            h++;\n          }\n\n          return [4\n          /*yield*/\n          , Math.sqrt(g / h)];\n\n        case 2:\n          _h.sent();\n\n          return [3\n          /*break*/\n          , 5];\n\n        case 3:\n          for (k = 0; k < b; ++k) {\n            l = c.current - e[k];\n            g += l * l;\n          }\n\n          return [4\n          /*yield*/\n          , Math.sqrt(g / b)];\n\n        case 4:\n          _h.sent();\n\n          _h.label = 5;\n\n        case 5:\n          return [3\n          /*break*/\n          , 1];\n\n        case 6:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  TrendCalculators.f = function (a, b) {\n    return toEnum(function () {\n      return TrendCalculators._f(a, b);\n    });\n  };\n\n  TrendCalculators.$t = markType(TrendCalculators, 'TrendCalculators');\n  return TrendCalculators;\n}(Base);\n\nexport { TrendCalculators };","map":{"version":3,"sources":["../../../../src/igniteui-core/lib/TrendCalculators.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\nhttps://www.infragistics.com/legal/license/igultimate-la\nhttps://www.infragistics.com/legal/license/igultimate-eula\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\n*/\nimport * as tslib_1 from \"tslib\";\nimport { Base, fromEnum, toEnum, markType, getEnumerator } from \"./type\";\nimport { isNaN_ } from \"./number\";\n/**\n * @hidden\n */\nvar TrendCalculators = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(TrendCalculators, _super);\n    function TrendCalculators() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TrendCalculators._g = function (a, b) {\n        var c, d, e, f, g, h, _h, _j, i, j, e_1_1;\n        var e_1, _k;\n        return tslib_1.__generator(this, function (_l) {\n            switch (_l.label) {\n                case 0:\n                    c = new Array(b);\n                    d = 0;\n                    for (d = 0; d < b; d++) {\n                        c[d] = 0;\n                    }\n                    e = NaN;\n                    f = NaN;\n                    g = NaN;\n                    h = NaN;\n                    d = 0;\n                    _l.label = 1;\n                case 1:\n                    _l.trys.push([1, 6, 7, 8]);\n                    _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n                    _l.label = 2;\n                case 2:\n                    if (!!_j.done)\n                        return [3 /*break*/, 5];\n                    i = _j.value;\n                    if (!isNaN_(i)) {\n                        j = d % b;\n                        if (d == 0) {\n                            g = 1;\n                            h = i;\n                            f = i;\n                            e = i;\n                        }\n                        else if (d < b) {\n                            g += (d + 1);\n                            e += i;\n                            f += (d + 1) * i;\n                            h = f / g;\n                        }\n                        else {\n                            f = f + (b * i) - e;\n                            h = f / g;\n                            e = e + i - c[j];\n                        }\n                        c[j] = i;\n                        ++d;\n                    }\n                    return [4 /*yield*/, h];\n                case 3:\n                    _l.sent();\n                    _l.label = 4;\n                case 4:\n                    _j = _h.next();\n                    return [3 /*break*/, 2];\n                case 5: return [3 /*break*/, 8];\n                case 6:\n                    e_1_1 = _l.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 8];\n                case 7:\n                    try {\n                        if (_j && !_j.done && (_k = _h.return))\n                            _k.call(_h);\n                    }\n                    finally {\n                        if (e_1)\n                            throw e_1.error;\n                    }\n                    return [7 /*endfinally*/];\n                case 8: return [2 /*return*/];\n            }\n        });\n    };\n    TrendCalculators.g = function (a, b) {\n        return toEnum(function () { return TrendCalculators._g(a, b); });\n    };\n    TrendCalculators._b = function (a, b) {\n        var c, d, e, _h, _j, f, e_2_1;\n        var e_2, _k;\n        return tslib_1.__generator(this, function (_l) {\n            switch (_l.label) {\n                case 0:\n                    c = 0;\n                    d = NaN;\n                    e = 2 / (1 + b);\n                    _l.label = 1;\n                case 1:\n                    _l.trys.push([1, 6, 7, 8]);\n                    _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n                    _l.label = 2;\n                case 2:\n                    if (!!_j.done)\n                        return [3 /*break*/, 5];\n                    f = _j.value;\n                    if (!isNaN_(f)) {\n                        if (c < b) {\n                            d = isNaN_(d) ? f : (d * c + f) / (c + 1);\n                        }\n                        else {\n                            d = (f - d) * e + d;\n                        }\n                        ++c;\n                    }\n                    return [4 /*yield*/, d];\n                case 3:\n                    _l.sent();\n                    _l.label = 4;\n                case 4:\n                    _j = _h.next();\n                    return [3 /*break*/, 2];\n                case 5: return [3 /*break*/, 8];\n                case 6:\n                    e_2_1 = _l.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3 /*break*/, 8];\n                case 7:\n                    try {\n                        if (_j && !_j.done && (_k = _h.return))\n                            _k.call(_h);\n                    }\n                    finally {\n                        if (e_2)\n                            throw e_2.error;\n                    }\n                    return [7 /*endfinally*/];\n                case 8: return [2 /*return*/];\n            }\n        });\n    };\n    TrendCalculators.b = function (a, b) {\n        return toEnum(function () { return TrendCalculators._b(a, b); });\n    };\n    TrendCalculators._c = function (a, b) {\n        var c, d, e, _h, _j, f, e_3_1;\n        var e_3, _k;\n        return tslib_1.__generator(this, function (_l) {\n            switch (_l.label) {\n                case 0:\n                    c = 0;\n                    d = NaN;\n                    e = 1 / b;\n                    _l.label = 1;\n                case 1:\n                    _l.trys.push([1, 6, 7, 8]);\n                    _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n                    _l.label = 2;\n                case 2:\n                    if (!!_j.done)\n                        return [3 /*break*/, 5];\n                    f = _j.value;\n                    if (!isNaN_(f)) {\n                        if (c < b) {\n                            d = isNaN_(d) ? f : (d * c + f) / (c + 1);\n                        }\n                        else {\n                            d = (f - d) * e + d;\n                        }\n                        ++c;\n                    }\n                    return [4 /*yield*/, d];\n                case 3:\n                    _l.sent();\n                    _l.label = 4;\n                case 4:\n                    _j = _h.next();\n                    return [3 /*break*/, 2];\n                case 5: return [3 /*break*/, 8];\n                case 6:\n                    e_3_1 = _l.sent();\n                    e_3 = { error: e_3_1 };\n                    return [3 /*break*/, 8];\n                case 7:\n                    try {\n                        if (_j && !_j.done && (_k = _h.return))\n                            _k.call(_h);\n                    }\n                    finally {\n                        if (e_3)\n                            throw e_3.error;\n                    }\n                    return [7 /*endfinally*/];\n                case 8: return [2 /*return*/];\n            }\n        });\n    };\n    TrendCalculators.c = function (a, b) {\n        return toEnum(function () { return TrendCalculators._c(a, b); });\n    };\n    TrendCalculators._a = function (a) {\n        var b, c, _h, _j, d, e_4_1;\n        var e_4, _k;\n        return tslib_1.__generator(this, function (_l) {\n            switch (_l.label) {\n                case 0:\n                    b = NaN;\n                    c = 0;\n                    _l.label = 1;\n                case 1:\n                    _l.trys.push([1, 6, 7, 8]);\n                    _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n                    _l.label = 2;\n                case 2:\n                    if (!!_j.done)\n                        return [3 /*break*/, 5];\n                    d = _j.value;\n                    if (!isNaN_(d)) {\n                        b = isNaN_(b) ? d : (b * c + d) / (c + 1);\n                        ++c;\n                    }\n                    return [4 /*yield*/, b];\n                case 3:\n                    _l.sent();\n                    _l.label = 4;\n                case 4:\n                    _j = _h.next();\n                    return [3 /*break*/, 2];\n                case 5: return [3 /*break*/, 8];\n                case 6:\n                    e_4_1 = _l.sent();\n                    e_4 = { error: e_4_1 };\n                    return [3 /*break*/, 8];\n                case 7:\n                    try {\n                        if (_j && !_j.done && (_k = _h.return))\n                            _k.call(_h);\n                    }\n                    finally {\n                        if (e_4)\n                            throw e_4.error;\n                    }\n                    return [7 /*endfinally*/];\n                case 8: return [2 /*return*/];\n            }\n        });\n    };\n    TrendCalculators.a = function (a) {\n        return toEnum(function () { return TrendCalculators._a(a); });\n    };\n    TrendCalculators._e = function (a, b) {\n        var c, d, e, _h, _j, f, g, h, e_5_1;\n        var e_5, _k;\n        return tslib_1.__generator(this, function (_l) {\n            switch (_l.label) {\n                case 0:\n                    c = new Array(b);\n                    d = 0;\n                    for (d = 0; d < b; d++) {\n                        c[d] = 0;\n                    }\n                    d = 0;\n                    e = NaN;\n                    _l.label = 1;\n                case 1:\n                    _l.trys.push([1, 6, 7, 8]);\n                    _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n                    _l.label = 2;\n                case 2:\n                    if (!!_j.done)\n                        return [3 /*break*/, 5];\n                    f = _j.value;\n                    if (!isNaN_(f)) {\n                        g = f / b;\n                        h = d % b;\n                        if (d < b) {\n                            e = isNaN_(e) ? f : (e * d + f) / (d + 1);\n                        }\n                        else {\n                            e = e + g - c[h];\n                        }\n                        c[h] = g;\n                        ++d;\n                    }\n                    return [4 /*yield*/, e];\n                case 3:\n                    _l.sent();\n                    _l.label = 4;\n                case 4:\n                    _j = _h.next();\n                    return [3 /*break*/, 2];\n                case 5: return [3 /*break*/, 8];\n                case 6:\n                    e_5_1 = _l.sent();\n                    e_5 = { error: e_5_1 };\n                    return [3 /*break*/, 8];\n                case 7:\n                    try {\n                        if (_j && !_j.done && (_k = _h.return))\n                            _k.call(_h);\n                    }\n                    finally {\n                        if (e_5)\n                            throw e_5.error;\n                    }\n                    return [7 /*endfinally*/];\n                case 8: return [2 /*return*/];\n            }\n        });\n    };\n    TrendCalculators.e = function (a, b) {\n        return toEnum(function () { return TrendCalculators._e(a, b); });\n    };\n    TrendCalculators._d = function (a, b) {\n        var c, d, e, _h, _j, f, g, h, e_6_1;\n        var e_6, _k;\n        return tslib_1.__generator(this, function (_l) {\n            switch (_l.label) {\n                case 0:\n                    c = new Array(b);\n                    d = 0;\n                    for (d = 0; d < b; d++) {\n                        c[d] = 0;\n                    }\n                    d = 0;\n                    e = NaN;\n                    _l.label = 1;\n                case 1:\n                    _l.trys.push([1, 6, 7, 8]);\n                    _h = tslib_1.__values(fromEnum(a)), _j = _h.next();\n                    _l.label = 2;\n                case 2:\n                    if (!!_j.done)\n                        return [3 /*break*/, 5];\n                    f = _j.value;\n                    if (!isNaN_(f)) {\n                        g = f;\n                        h = d % b;\n                        if (d < b) {\n                            e = isNaN_(e) ? g : e + g;\n                        }\n                        else {\n                            e = e + g - c[h];\n                        }\n                        c[h] = g;\n                        ++d;\n                    }\n                    return [4 /*yield*/, e];\n                case 3:\n                    _l.sent();\n                    _l.label = 4;\n                case 4:\n                    _j = _h.next();\n                    return [3 /*break*/, 2];\n                case 5: return [3 /*break*/, 8];\n                case 6:\n                    e_6_1 = _l.sent();\n                    e_6 = { error: e_6_1 };\n                    return [3 /*break*/, 8];\n                case 7:\n                    try {\n                        if (_j && !_j.done && (_k = _h.return))\n                            _k.call(_h);\n                    }\n                    finally {\n                        if (e_6)\n                            throw e_6.error;\n                    }\n                    return [7 /*endfinally*/];\n                case 8: return [2 /*return*/];\n            }\n        });\n    };\n    TrendCalculators.d = function (a, b) {\n        return toEnum(function () { return TrendCalculators._d(a, b); });\n    };\n    TrendCalculators._f = function (a, b) {\n        var c, d, e, f, g, h, i, j, k, l;\n        return tslib_1.__generator(this, function (_h) {\n            switch (_h.label) {\n                case 0:\n                    c = getEnumerator(TrendCalculators.e(a, b));\n                    d = getEnumerator(a);\n                    e = new Array(b);\n                    f = 0;\n                    for (f = 0; f < b; f++) {\n                        e[f] = 0;\n                    }\n                    f = 0;\n                    _h.label = 1;\n                case 1:\n                    if (!(d.moveNext() && c.moveNext()))\n                        return [3 /*break*/, 6];\n                    e[(f++) % b] = d.current;\n                    g = 0;\n                    if (!(f < b))\n                        return [3 /*break*/, 3];\n                    h = 0;\n                    for (i = 0; i < f; i++) {\n                        j = (c.current - e[i]);\n                        g += j * j;\n                        h++;\n                    }\n                    return [4 /*yield*/, Math.sqrt(g / h)];\n                case 2:\n                    _h.sent();\n                    return [3 /*break*/, 5];\n                case 3:\n                    for (k = 0; k < b; ++k) {\n                        l = (c.current - e[k]);\n                        g += l * l;\n                    }\n                    return [4 /*yield*/, Math.sqrt(g / b)];\n                case 4:\n                    _h.sent();\n                    _h.label = 5;\n                case 5: return [3 /*break*/, 1];\n                case 6: return [2 /*return*/];\n            }\n        });\n    };\n    TrendCalculators.f = function (a, b) {\n        return toEnum(function () { return TrendCalculators._f(a, b); });\n    };\n    TrendCalculators.$t = markType(TrendCalculators, 'TrendCalculators');\n    return TrendCalculators;\n}(Base));\nexport { TrendCalculators };\n//# sourceMappingURL=TrendCalculators.js.map\n"]},"metadata":{},"sourceType":"module"}