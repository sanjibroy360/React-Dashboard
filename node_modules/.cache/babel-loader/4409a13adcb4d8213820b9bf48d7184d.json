{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { MarkerType_$type } from \"./MarkerType\";\nimport { IgrSeries } from \"./igr-series\";\nimport { ensureEnum, brushToString, stringToBrush } from \"igniteui-react-core\";\n/**\n * Represents the base class for series containing markers.\n*\n* MarkerSeries represents the base class for series containing markers.\n*\n* Example:\n*\n* ```ts\n*  <IgrDataChart\n*     dataSource={this.state.dataSource} >\n*\n*     <IgrCategoryXAxis name=\"xAxis\" />\n*     <IgrNumericYAxis name=\"yAxis\" />\n*\n*     <IgrColumnSeries\n*      name=\"series1\"\n*     xAxisName=\"xAxis\"\n* \tyAxisName=\"yAxis\"\n* \tvalueMemberPath=\"Value\" />\n*  </IgrDataChart>\n* ```\n*\n* ```ts\n* this.series = new IgrMarkerSeries({name: \"series\"});\n* this.series.xAxis = this.categoryXAxis;\n* this.series.yAxis = this.numericYAxis;\n* this.series.xAxisName = \"timeXAxis\";\n* this.series.yAxisName = \"numericYAxis\";\n* this.series.volumeMemberPath=\"Volume\";\n* ```\n*/\n\nvar IgrMarkerSeries =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(IgrMarkerSeries, _super);\n\n  function IgrMarkerSeries(props) {\n    return _super.call(this, props) || this;\n  }\n\n  Object.defineProperty(IgrMarkerSeries.prototype, \"i\", {\n    /**\n                                 * @hidden\n                                 */\n    get: function () {\n      return this._implementation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IgrMarkerSeries.prototype, \"hasMarkers\", {\n    /**\n     * Returns whether the current series supports visual markers.\n    *\n    * `hasMarkers` property is overriden, it returns whether the current series supports visual markers. You can use it like this:\n    *\n    * ```ts\n    *  let gotMarkers: boolean = this.series.hasMarkers;\n    * ```\n    */\n    get: function () {\n      return this.i.hasMarkers;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IgrMarkerSeries.prototype, \"markerType\", {\n    /**\n     * Gets or sets the marker type for the current series object.\n     * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.\n    *\n    * `markerType` property gets or sets the marker type for the current series object. For example, you can set it like this:\n    *\n    * ```ts\n    * this.series.markerType = \"circle\";\n    * ```\n    *\n    * ```ts\n    *  <IgrDataChart\n    *     dataSource={this.state.dataSource} >\n    *\n    *     <IgrCategoryXAxis name=\"xAxis\" />\n    *     <IgrNumericYAxis name=\"yAxis\" />\n    *\n    *     <IgrColumnSeries\n    *      name=\"series1\"\n    *     xAxisName=\"xAxis\"\n    * \tyAxisName=\"yAxis\"\n    * \tvalueMemberPath=\"Value\"\n    * \tmarkerType = \"circle\"/>\n    *  </IgrDataChart>\n    * ```\n    */\n    get: function () {\n      return this.i.l2;\n    },\n    set: function (v) {\n      this.i.l2 = ensureEnum(MarkerType_$type, v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IgrMarkerSeries.prototype, \"markerTemplate\", {\n    /**\n     * Gets or sets the MarkerTemplate for the current series object.\n    *\n    * `markerTemplate` property gets or sets the MarkerTemplate for the current series object. For example, you can use it like this:\n    */\n    get: function () {\n      return this.i.mn;\n    },\n    set: function (v) {\n      this.i.mn = v;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IgrMarkerSeries.prototype, \"markerThickness\", {\n    /**\n     * Gets or sets thickness of the marker outline\n    */\n    get: function () {\n      return this.i.l7;\n    },\n    set: function (v) {\n      this.i.l7 = +v;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IgrMarkerSeries.prototype, \"actualMarkerTemplate\", {\n    /**\n     * Gets the effective marker template for the current series object.\n    *\n    * `actualMarkerTemplate` property gets the effective marker template for the current series object. You can use it like this:\n    */\n    get: function () {\n      return this.i.ml;\n    },\n    set: function (v) {\n      this.i.ml = v;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IgrMarkerSeries.prototype, \"markerBrush\", {\n    /**\n     * Gets or sets the brush that specifies how the current series object's marker interiors are painted.\n    *\n    * `markerBrush` property gets or sets the brush that specifies how the current series object's marker interiors are painted. You can use it like this:\n    *\n    * ```ts\n    * this.series.markerBrush = \"red\";\n    * ```\n    *\n    * ```ts\n    *  <IgrDataChart\n    *     dataSource={this.state.dataSource} >\n    *\n    *     <IgrCategoryXAxis name=\"xAxis\" />\n    *     <IgrNumericYAxis name=\"yAxis\" />\n    *\n    *     <IgrColumnSeries\n    *      name=\"series1\"\n    *     xAxisName=\"xAxis\"\n    * \tyAxisName=\"yAxis\"\n    * \tvalueMemberPath=\"Value\"\n    * \tmarkerBrush = \"blue\" />\n    *  </IgrDataChart>\n    * ```\n    */\n    get: function () {\n      return brushToString(this.i.m1);\n    },\n    set: function (v) {\n      this.i.m1 = stringToBrush(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IgrMarkerSeries.prototype, \"actualMarkerBrush\", {\n    /**\n     * Gets the effective marker brush for the current series object.\n    *\n    * `actualMarkerBrush` property gets the effective marker brush for the current series object. For example, you can use it like this:\n    *\n    * ```ts\n    *  let effectiveMarkerBrush: string = this.series.actualMarkerBrush;\n    *\n    * ```\n    */\n    get: function () {\n      return brushToString(this.i.mz);\n    },\n    set: function (v) {\n      this.i.mz = stringToBrush(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IgrMarkerSeries.prototype, \"markerOutline\", {\n    /**\n     * Gets or sets the brush that specifies how the current series object's marker outlines are painted.\n    *\n    * `markerOutline` property gets or sets the brush that specifies how the current series object's marker outlines are painted. You can use it like this:\n    *\n    * ```ts\n    * this.series.markerOutline = \"red\";\n    * ```\n    *\n    * ```ts\n    *  <IgrDataChart\n    *     dataSource={this.state.dataSource} >\n    *\n    *     <IgrCategoryXAxis name=\"xAxis\" />\n    *     <IgrNumericYAxis name=\"yAxis\" />\n    *\n    *     <IgrColumnSeries\n    *      name=\"series1\"\n    *     xAxisName=\"xAxis\"\n    * \tyAxisName=\"yAxis\"\n    * \tvalueMemberPath=\"Value\"\n    * \tmarkerOutline = \"blue\" />\n    *  </IgrDataChart>\n    * ```\n    */\n    get: function () {\n      return brushToString(this.i.m2);\n    },\n    set: function (v) {\n      this.i.m2 = stringToBrush(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IgrMarkerSeries.prototype, \"actualMarkerOutline\", {\n    /**\n     * Gets the effective marker outline for the current series object.\n    *\n    *     `ActualMarkerOutline` property gets the effective marker outline for the current series object. You can use it like this:\n    *\n    * ```ts\n    *  let effectiveMarkerOutline: string = this.series.actualMarkerOutline;\n    *\n    * ```\n    */\n    get: function () {\n      return brushToString(this.i.m0);\n    },\n    set: function (v) {\n      this.i.m0 = stringToBrush(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return IgrMarkerSeries;\n}(IgrSeries);\n\nexport { IgrMarkerSeries };","map":{"version":3,"sources":["../../../../src/igniteui-charts/lib/igr-marker-series.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { MarkerType_$type } from \"./MarkerType\";\nimport { IgrSeries } from \"./igr-series\";\nimport { ensureEnum, brushToString, stringToBrush } from \"igniteui-react-core\";\n/**\n * Represents the base class for series containing markers.\n*\n* MarkerSeries represents the base class for series containing markers.\n*\n* Example:\n*\n* ```ts\n*  <IgrDataChart\n*     dataSource={this.state.dataSource} >\n*\n*     <IgrCategoryXAxis name=\"xAxis\" />\n*     <IgrNumericYAxis name=\"yAxis\" />\n*\n*     <IgrColumnSeries\n*      name=\"series1\"\n*     xAxisName=\"xAxis\"\n* \tyAxisName=\"yAxis\"\n* \tvalueMemberPath=\"Value\" />\n*  </IgrDataChart>\n* ```\n*\n* ```ts\n* this.series = new IgrMarkerSeries({name: \"series\"});\n* this.series.xAxis = this.categoryXAxis;\n* this.series.yAxis = this.numericYAxis;\n* this.series.xAxisName = \"timeXAxis\";\n* this.series.yAxisName = \"numericYAxis\";\n* this.series.volumeMemberPath=\"Volume\";\n* ```\n*/\nvar IgrMarkerSeries = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(IgrMarkerSeries, _super);\n    function IgrMarkerSeries(props) {\n        return _super.call(this, props) || this;\n    }\n    Object.defineProperty(IgrMarkerSeries.prototype, \"i\", {\n        /**\n                                     * @hidden\n                                     */\n        get: function () {\n            return this._implementation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IgrMarkerSeries.prototype, \"hasMarkers\", {\n        /**\n         * Returns whether the current series supports visual markers.\n        *\n        * `hasMarkers` property is overriden, it returns whether the current series supports visual markers. You can use it like this:\n        *\n        * ```ts\n        *  let gotMarkers: boolean = this.series.hasMarkers;\n        * ```\n        */\n        get: function () {\n            return this.i.hasMarkers;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IgrMarkerSeries.prototype, \"markerType\", {\n        /**\n         * Gets or sets the marker type for the current series object.\n         * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.\n        *\n        * `markerType` property gets or sets the marker type for the current series object. For example, you can set it like this:\n        *\n        * ```ts\n        * this.series.markerType = \"circle\";\n        * ```\n        *\n        * ```ts\n        *  <IgrDataChart\n        *     dataSource={this.state.dataSource} >\n        *\n        *     <IgrCategoryXAxis name=\"xAxis\" />\n        *     <IgrNumericYAxis name=\"yAxis\" />\n        *\n        *     <IgrColumnSeries\n        *      name=\"series1\"\n        *     xAxisName=\"xAxis\"\n        * \tyAxisName=\"yAxis\"\n        * \tvalueMemberPath=\"Value\"\n        * \tmarkerType = \"circle\"/>\n        *  </IgrDataChart>\n        * ```\n        */\n        get: function () {\n            return this.i.l2;\n        },\n        set: function (v) {\n            this.i.l2 = ensureEnum(MarkerType_$type, v);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IgrMarkerSeries.prototype, \"markerTemplate\", {\n        /**\n         * Gets or sets the MarkerTemplate for the current series object.\n        *\n        * `markerTemplate` property gets or sets the MarkerTemplate for the current series object. For example, you can use it like this:\n        */\n        get: function () {\n            return this.i.mn;\n        },\n        set: function (v) {\n            this.i.mn = v;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IgrMarkerSeries.prototype, \"markerThickness\", {\n        /**\n         * Gets or sets thickness of the marker outline\n        */\n        get: function () {\n            return this.i.l7;\n        },\n        set: function (v) {\n            this.i.l7 = +v;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IgrMarkerSeries.prototype, \"actualMarkerTemplate\", {\n        /**\n         * Gets the effective marker template for the current series object.\n        *\n        * `actualMarkerTemplate` property gets the effective marker template for the current series object. You can use it like this:\n        */\n        get: function () {\n            return this.i.ml;\n        },\n        set: function (v) {\n            this.i.ml = v;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IgrMarkerSeries.prototype, \"markerBrush\", {\n        /**\n         * Gets or sets the brush that specifies how the current series object's marker interiors are painted.\n        *\n        * `markerBrush` property gets or sets the brush that specifies how the current series object's marker interiors are painted. You can use it like this:\n        *\n        * ```ts\n        * this.series.markerBrush = \"red\";\n        * ```\n        *\n        * ```ts\n        *  <IgrDataChart\n        *     dataSource={this.state.dataSource} >\n        *\n        *     <IgrCategoryXAxis name=\"xAxis\" />\n        *     <IgrNumericYAxis name=\"yAxis\" />\n        *\n        *     <IgrColumnSeries\n        *      name=\"series1\"\n        *     xAxisName=\"xAxis\"\n        * \tyAxisName=\"yAxis\"\n        * \tvalueMemberPath=\"Value\"\n        * \tmarkerBrush = \"blue\" />\n        *  </IgrDataChart>\n        * ```\n        */\n        get: function () {\n            return brushToString(this.i.m1);\n        },\n        set: function (v) {\n            this.i.m1 = stringToBrush(v);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IgrMarkerSeries.prototype, \"actualMarkerBrush\", {\n        /**\n         * Gets the effective marker brush for the current series object.\n        *\n        * `actualMarkerBrush` property gets the effective marker brush for the current series object. For example, you can use it like this:\n        *\n        * ```ts\n        *  let effectiveMarkerBrush: string = this.series.actualMarkerBrush;\n        *\n        * ```\n        */\n        get: function () {\n            return brushToString(this.i.mz);\n        },\n        set: function (v) {\n            this.i.mz = stringToBrush(v);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IgrMarkerSeries.prototype, \"markerOutline\", {\n        /**\n         * Gets or sets the brush that specifies how the current series object's marker outlines are painted.\n        *\n        * `markerOutline` property gets or sets the brush that specifies how the current series object's marker outlines are painted. You can use it like this:\n        *\n        * ```ts\n        * this.series.markerOutline = \"red\";\n        * ```\n        *\n        * ```ts\n        *  <IgrDataChart\n        *     dataSource={this.state.dataSource} >\n        *\n        *     <IgrCategoryXAxis name=\"xAxis\" />\n        *     <IgrNumericYAxis name=\"yAxis\" />\n        *\n        *     <IgrColumnSeries\n        *      name=\"series1\"\n        *     xAxisName=\"xAxis\"\n        * \tyAxisName=\"yAxis\"\n        * \tvalueMemberPath=\"Value\"\n        * \tmarkerOutline = \"blue\" />\n        *  </IgrDataChart>\n        * ```\n        */\n        get: function () {\n            return brushToString(this.i.m2);\n        },\n        set: function (v) {\n            this.i.m2 = stringToBrush(v);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IgrMarkerSeries.prototype, \"actualMarkerOutline\", {\n        /**\n         * Gets the effective marker outline for the current series object.\n        *\n        *     `ActualMarkerOutline` property gets the effective marker outline for the current series object. You can use it like this:\n        *\n        * ```ts\n        *  let effectiveMarkerOutline: string = this.series.actualMarkerOutline;\n        *\n        * ```\n        */\n        get: function () {\n            return brushToString(this.i.m0);\n        },\n        set: function (v) {\n            this.i.m0 = stringToBrush(v);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return IgrMarkerSeries;\n}(IgrSeries));\nexport { IgrMarkerSeries };\n//# sourceMappingURL=igr-marker-series.js.map\n"]},"metadata":{},"sourceType":"module"}